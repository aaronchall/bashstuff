echo $SP1
SP1="command prompt"
type # determine how shell finds command
file # classifies file based on content
date # displays date and time
alias # manage command shortcuts
unalias
sort # sorts contents of file (by line?)
uniq # print out unique lines in a sorted file
comm # print common line in pair of sorted files
ptx # produce permuted indexes
sleep # go to sleep for seconds
strings # display printable strings from a binary file
time # time a command

cat -v # flag shows viewable chars

cat foo bar | head -2
cat foo bar | tail -2

more # h gives help
less

# lpr mostly replaced by CUPS (which has web interface), but here's commands
lpr # print to default printer, can pipe and redirect into
lpr -MyPrinterName foofile
lpq # view print queue
lprm 14 # remove job 14
lpq -MyPrinterName
lpc # view print system stats

cut # cuts fields out of file, whitespace delimited default or other char with -d, 
tail /etc/passwd | cut -d: -f1,5 # f flag followed by list or range by dash for just those fields
cut -c1-3 # cut by char position, here chars 1,2,3 from the file

tr 'a-z' 'A-Z' < foo.file  # translate lower to upper
cat foofile | tr -dc 'aeiou\n' # -d will delete chars -dc will delete complements
wc foofile # word count of file, -l line count, -c char count, -w word count, default is all (-lwc)

grep word foofile # looks for "word" in file, returns line
grep -i word foofile # ignore case
grep '[aeiou]' foofile # look for lines with a vowel in them
grep 'a[^n]' foofile # look for lines with a not followed by n
grep 'a.*e' foofile # a must be followed by e with 0 or more other chars in between
grep 'a.a' foofile # two a's with any char between
grep '^a' foofile # a at beginning of line
grep 'a$' foofile # a at end of line, ^ and & lose this meaning at other places in regex

sort -r foofile # reverse sorts
sort -f foofile # ignore case (default is uppercases first)
sort foofile foofile2 # can sort more than one at a time
sort -t: -k2 foofile # using : as delimeter, sort by 2nd field, can numeric sort with -n
tsort # topological sort utility

cmp foofile1 foofile2 # compares files, reports if they differ (nothing if they don't)
cksum foofile1 foofile2

comm foofile1 foofile2 # if files are sorted, can search for common lines
comm -13 foofile1 foofile2 #suppress lines unique to file 1, suppresses lines in both files

diff -c foofile1 foofile2 # shows diff used in rcs and cvs for version control, -c more readable output, -u too
# zcomp, zdiff # utilities to compare compressed files

paste foofile foofile2 foofile3 # concatenate horizontally, joining with tabs
paste -s foofile # joins lines on a single line with tabs
paste -d ':\n' foofile # can control number of columns and delimiters (here, separate alternating by : then \n)

join -t= -12 foofile foofile2 # match fields delimited by = (tab default), here key field for file 1 is field 2
join -t= -12 -o 1.2 2.2 foofile foofile2 # -o flag can supply file.field pairs to output, instead of default 
# here join on second field, and output second field of each file.


multi-user!!!

mail foo@bar.com # enter subject, type message, ctrl-D or single period on lone line to stop, enter CC list
mail # with no commands, opens mailbox and presents list of messages, 
#can type number of message to view, d deletes, q quits

# Mutt is a client based on ELM with ideas from PINE and other freeware email clients
# POP3/IMAP services must be running in Linux for them to work on Outlook, e.g. in Windows shell:
telnet linux_machine_domain_name 143 # tests for IMAP server, exit with ". logout"
telnet linux_machine_domain_name 25 # show if mail server exists and is accessible, exit with "quit"
telnet linux_machine_domain_name 110 # tests for POP3 server, exit with "quit"
# if no response, possible firewall or no service

### Managing Processes ###

ps # show current status of process, no args just shows the ones belonging to the current login session
ps -f # show full information, including parent PID (PPID), starttime (STIME) and user id UID
ps -e # every process, can limit to users (-u) groups (-g) PIDs (-p) and terminal (-t)
ps -u user_a
ps -t tty4
ps -p 17075
ps -fp 17075
# two ways to manage processes: kill, skill and pkill or /proc interface
# signals: ctrl-c sends INT and ctrl-\ sends QUIT, HUP is a modem hangup, 
# kill can only send to own processes, unless superuser (root)
# sending to login shell kill -1 or kill -HUP will cause shell to terminate and log you out
kill # default is 15
kill <pid> # syntax
kill -9 <pid> # KILL
kill -1 <bash PID> # logout, i.e. HUP

# /proc entries
ls -l /proc/<pid>
tr '\0' '\r' < /proc/<pid>/environ # see the environment, translate ascii nulls to LF chars
ls -l /proc/<pid>/fd # file descriptor, see a processes open files (called file handle on some "other" systems)
umount /home # unmount the home file system, can't be done if a file process is open
ls -l /proc/*/fd | grep /home # find all files open in home filesystem

# end command with & to create running job in background
# ctrl-z to stop a running job
jobs # view jobs, '+' current job, '-' next to become current, status, command line used
fg # foreground the current job
^Z # ctrl-z to stop it
bg # background the job while running (like adding & to end)
fg %<n> # specify by job number, kill can use same specification, replacing the %n with the pid
# kill can also send SIGSTOP and SIGCONT

Scheduling
# cron, at, and batch to schedule tasks
# use cron for repetitive tasks
# crontab provides table of cron entries format is:
# min hr day mo dayofwk cmd
# create a new crontab,  
cat > mycron 
4 2 * * * /home/ajax/bin/mybackup
^D
crontab mycron
crontab -l # list the contents
crontab -r # remove the table
crontab -e # edit the table with editor named in editor or visual environment variables
# cron commands are run using the /bin/sh, standard Bourne shell
# output is typically captured and emailed to user, so common to redirect output, e.g.
3 5 * * 1-5 morning_job > /dev/null 2>&1
# shell env not the same as login env, may need to setup own environment including PATH


at 10am tomorrow # schedule one-off job
at> /home/me/bin/reminder # prompt
at> <EOT> #  ctrl-d
# can use now + 3 days, times before current assumed to be tomorrow, days and months as names, 
# now tomorrow, noon, midnight, teatime (4pm) also understood

# batch is subset of at, defers processing until system load is light enough to continue
# batch waits until load average drops below .8 (busy system may have load average of 4.0+)













 

















